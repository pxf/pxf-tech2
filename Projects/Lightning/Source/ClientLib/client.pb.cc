// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "client.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace client {

namespace {

const ::google::protobuf::Descriptor* Hello_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Hello_reflection_ = NULL;
const ::google::protobuf::Descriptor* AllocateClient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AllocateClient_reflection_ = NULL;
const ::google::protobuf::Descriptor* AllocateResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AllocateResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* Data_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Data_reflection_ = NULL;
const ::google::protobuf::Descriptor* Tasks_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Tasks_reflection_ = NULL;
const ::google::protobuf::Descriptor* Tasks_Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Tasks_Task_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_client_2eproto() {
  protobuf_AddDesc_client_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "client.proto");
  GOOGLE_CHECK(file != NULL);
  Hello_descriptor_ = file->message_type(0);
  static const int Hello_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello, session_id_),
  };
  Hello_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Hello_descriptor_,
      Hello::default_instance_,
      Hello_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hello, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Hello));
  AllocateClient_descriptor_ = file->message_type(1);
  static const int AllocateClient_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateClient, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateClient, batchhash_),
  };
  AllocateClient_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AllocateClient_descriptor_,
      AllocateClient::default_instance_,
      AllocateClient_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateClient, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateClient, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AllocateClient));
  AllocateResponse_descriptor_ = file->message_type(2);
  static const int AllocateResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateResponse, hasdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateResponse, isavailable_),
  };
  AllocateResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AllocateResponse_descriptor_,
      AllocateResponse::default_instance_,
      AllocateResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AllocateResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AllocateResponse));
  Data_descriptor_ = file->message_type(3);
  static const int Data_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, batchhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, datasize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, datatype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, returnaddress_),
  };
  Data_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Data_descriptor_,
      Data::default_instance_,
      Data_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Data, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Data));
  Tasks_descriptor_ = file->message_type(4);
  static const int Tasks_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks, batchhash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks, task_),
  };
  Tasks_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Tasks_descriptor_,
      Tasks::default_instance_,
      Tasks_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Tasks));
  Tasks_Task_descriptor_ = Tasks_descriptor_->nested_type(0);
  static const int Tasks_Task_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks_Task, tasksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks_Task, task_),
  };
  Tasks_Task_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Tasks_Task_descriptor_,
      Tasks_Task::default_instance_,
      Tasks_Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks_Task, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Tasks_Task, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Tasks_Task));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_client_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Hello_descriptor_, &Hello::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AllocateClient_descriptor_, &AllocateClient::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AllocateResponse_descriptor_, &AllocateResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Data_descriptor_, &Data::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Tasks_descriptor_, &Tasks::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Tasks_Task_descriptor_, &Tasks_Task::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_client_2eproto() {
  delete Hello::default_instance_;
  delete Hello_reflection_;
  delete AllocateClient::default_instance_;
  delete AllocateClient_reflection_;
  delete AllocateResponse::default_instance_;
  delete AllocateResponse_reflection_;
  delete Data::default_instance_;
  delete Data_reflection_;
  delete Tasks::default_instance_;
  delete Tasks_reflection_;
  delete Tasks_Task::default_instance_;
  delete Tasks_Task_reflection_;
}

void protobuf_AddDesc_client_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014client.proto\022\006client\":\n\005Hello\022\017\n\007addre"
    "ss\030\001 \002(\t\022\014\n\004port\030\002 \002(\005\022\022\n\nsession_id\030\003 \002"
    "(\005\"3\n\016AllocateClient\022\016\n\006amount\030\001 \002(\005\022\021\n\t"
    "batchhash\030\002 \002(\t\"8\n\020AllocateResponse\022\017\n\007h"
    "asdata\030\001 \002(\010\022\023\n\013isavailable\030\002 \002(\010\"b\n\004Dat"
    "a\022\021\n\tbatchhash\030\001 \002(\t\022\020\n\010datasize\030\002 \002(\005\022\020"
    "\n\010datatype\030\003 \002(\005\022\014\n\004data\030\004 \002(\t\022\025\n\rreturn"
    "address\030\005 \002(\t\"d\n\005Tasks\022\021\n\tbatchhash\030\001 \002("
    "\t\022 \n\004task\030\002 \003(\0132\022.client.Tasks.Task\032&\n\004T"
    "ask\022\020\n\010tasksize\030\001 \002(\005\022\014\n\004task\030\002 \002(\t", 395);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "client.proto", &protobuf_RegisterTypes);
  Hello::default_instance_ = new Hello();
  AllocateClient::default_instance_ = new AllocateClient();
  AllocateResponse::default_instance_ = new AllocateResponse();
  Data::default_instance_ = new Data();
  Tasks::default_instance_ = new Tasks();
  Tasks_Task::default_instance_ = new Tasks_Task();
  Hello::default_instance_->InitAsDefaultInstance();
  AllocateClient::default_instance_->InitAsDefaultInstance();
  AllocateResponse::default_instance_->InitAsDefaultInstance();
  Data::default_instance_->InitAsDefaultInstance();
  Tasks::default_instance_->InitAsDefaultInstance();
  Tasks_Task::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_client_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_client_2eproto {
  StaticDescriptorInitializer_client_2eproto() {
    protobuf_AddDesc_client_2eproto();
  }
} static_descriptor_initializer_client_2eproto_;


// ===================================================================

const ::std::string Hello::_default_address_;
#ifndef _MSC_VER
const int Hello::kAddressFieldNumber;
const int Hello::kPortFieldNumber;
const int Hello::kSessionIdFieldNumber;
#endif  // !_MSC_VER

Hello::Hello()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Hello::InitAsDefaultInstance() {
}

Hello::Hello(const Hello& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Hello::SharedCtor() {
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&_default_address_);
  port_ = 0;
  session_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Hello::~Hello() {
  SharedDtor();
}

void Hello::SharedDtor() {
  if (address_ != &_default_address_) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void Hello::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Hello::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Hello_descriptor_;
}

const Hello& Hello::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();  return *default_instance_;
}

Hello* Hello::default_instance_ = NULL;

Hello* Hello::New() const {
  return new Hello;
}

void Hello::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (address_ != &_default_address_) {
        address_->clear();
      }
    }
    port_ = 0;
    session_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Hello::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }
      
      // required int32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_session_id;
        break;
      }
      
      // required int32 session_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &session_id_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Hello::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string address = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->address(), output);
  }
  
  // required int32 port = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }
  
  // required int32 session_id = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->session_id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Hello::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string address = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }
  
  // required int32 port = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->port(), target);
  }
  
  // required int32 session_id = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->session_id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Hello::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }
    
    // required int32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }
    
    // required int32 session_id = 3;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->session_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hello::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Hello* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Hello*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Hello::MergeFrom(const Hello& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_address(from.address());
    }
    if (from._has_bit(1)) {
      set_port(from.port());
    }
    if (from._has_bit(2)) {
      set_session_id(from.session_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Hello::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Hello::CopyFrom(const Hello& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hello::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Hello::Swap(Hello* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(port_, other->port_);
    std::swap(session_id_, other->session_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Hello::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Hello_descriptor_;
  metadata.reflection = Hello_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string AllocateClient::_default_batchhash_;
#ifndef _MSC_VER
const int AllocateClient::kAmountFieldNumber;
const int AllocateClient::kBatchhashFieldNumber;
#endif  // !_MSC_VER

AllocateClient::AllocateClient()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AllocateClient::InitAsDefaultInstance() {
}

AllocateClient::AllocateClient(const AllocateClient& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AllocateClient::SharedCtor() {
  _cached_size_ = 0;
  amount_ = 0;
  batchhash_ = const_cast< ::std::string*>(&_default_batchhash_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AllocateClient::~AllocateClient() {
  SharedDtor();
}

void AllocateClient::SharedDtor() {
  if (batchhash_ != &_default_batchhash_) {
    delete batchhash_;
  }
  if (this != default_instance_) {
  }
}

void AllocateClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AllocateClient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AllocateClient_descriptor_;
}

const AllocateClient& AllocateClient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();  return *default_instance_;
}

AllocateClient* AllocateClient::default_instance_ = NULL;

AllocateClient* AllocateClient::New() const {
  return new AllocateClient;
}

void AllocateClient::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    amount_ = 0;
    if (_has_bit(1)) {
      if (batchhash_ != &_default_batchhash_) {
        batchhash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AllocateClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 amount = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &amount_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_batchhash;
        break;
      }
      
      // required string batchhash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_batchhash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_batchhash()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->batchhash().data(), this->batchhash().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AllocateClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 amount = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->amount(), output);
  }
  
  // required string batchhash = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->batchhash().data(), this->batchhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->batchhash(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AllocateClient::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 amount = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->amount(), target);
  }
  
  // required string batchhash = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->batchhash().data(), this->batchhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->batchhash(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AllocateClient::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 amount = 1;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->amount());
    }
    
    // required string batchhash = 2;
    if (has_batchhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->batchhash());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AllocateClient::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AllocateClient* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AllocateClient*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AllocateClient::MergeFrom(const AllocateClient& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_amount(from.amount());
    }
    if (from._has_bit(1)) {
      set_batchhash(from.batchhash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AllocateClient::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AllocateClient::CopyFrom(const AllocateClient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocateClient::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AllocateClient::Swap(AllocateClient* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(batchhash_, other->batchhash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AllocateClient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AllocateClient_descriptor_;
  metadata.reflection = AllocateClient_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AllocateResponse::kHasdataFieldNumber;
const int AllocateResponse::kIsavailableFieldNumber;
#endif  // !_MSC_VER

AllocateResponse::AllocateResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AllocateResponse::InitAsDefaultInstance() {
}

AllocateResponse::AllocateResponse(const AllocateResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AllocateResponse::SharedCtor() {
  _cached_size_ = 0;
  hasdata_ = false;
  isavailable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AllocateResponse::~AllocateResponse() {
  SharedDtor();
}

void AllocateResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AllocateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AllocateResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AllocateResponse_descriptor_;
}

const AllocateResponse& AllocateResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();  return *default_instance_;
}

AllocateResponse* AllocateResponse::default_instance_ = NULL;

AllocateResponse* AllocateResponse::New() const {
  return new AllocateResponse;
}

void AllocateResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    hasdata_ = false;
    isavailable_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AllocateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool hasdata = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hasdata_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isavailable;
        break;
      }
      
      // required bool isavailable = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isavailable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isavailable_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AllocateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool hasdata = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->hasdata(), output);
  }
  
  // required bool isavailable = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isavailable(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AllocateResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool hasdata = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->hasdata(), target);
  }
  
  // required bool isavailable = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isavailable(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AllocateResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool hasdata = 1;
    if (has_hasdata()) {
      total_size += 1 + 1;
    }
    
    // required bool isavailable = 2;
    if (has_isavailable()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AllocateResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AllocateResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AllocateResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AllocateResponse::MergeFrom(const AllocateResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_hasdata(from.hasdata());
    }
    if (from._has_bit(1)) {
      set_isavailable(from.isavailable());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AllocateResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AllocateResponse::CopyFrom(const AllocateResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AllocateResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AllocateResponse::Swap(AllocateResponse* other) {
  if (other != this) {
    std::swap(hasdata_, other->hasdata_);
    std::swap(isavailable_, other->isavailable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AllocateResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AllocateResponse_descriptor_;
  metadata.reflection = AllocateResponse_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Data::_default_batchhash_;
const ::std::string Data::_default_data_;
const ::std::string Data::_default_returnaddress_;
#ifndef _MSC_VER
const int Data::kBatchhashFieldNumber;
const int Data::kDatasizeFieldNumber;
const int Data::kDatatypeFieldNumber;
const int Data::kDataFieldNumber;
const int Data::kReturnaddressFieldNumber;
#endif  // !_MSC_VER

Data::Data()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Data::InitAsDefaultInstance() {
}

Data::Data(const Data& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Data::SharedCtor() {
  _cached_size_ = 0;
  batchhash_ = const_cast< ::std::string*>(&_default_batchhash_);
  datasize_ = 0;
  datatype_ = 0;
  data_ = const_cast< ::std::string*>(&_default_data_);
  returnaddress_ = const_cast< ::std::string*>(&_default_returnaddress_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Data::~Data() {
  SharedDtor();
}

void Data::SharedDtor() {
  if (batchhash_ != &_default_batchhash_) {
    delete batchhash_;
  }
  if (data_ != &_default_data_) {
    delete data_;
  }
  if (returnaddress_ != &_default_returnaddress_) {
    delete returnaddress_;
  }
  if (this != default_instance_) {
  }
}

void Data::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Data::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Data_descriptor_;
}

const Data& Data::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();  return *default_instance_;
}

Data* Data::default_instance_ = NULL;

Data* Data::New() const {
  return new Data;
}

void Data::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (batchhash_ != &_default_batchhash_) {
        batchhash_->clear();
      }
    }
    datasize_ = 0;
    datatype_ = 0;
    if (_has_bit(3)) {
      if (data_ != &_default_data_) {
        data_->clear();
      }
    }
    if (_has_bit(4)) {
      if (returnaddress_ != &_default_returnaddress_) {
        returnaddress_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Data::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string batchhash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_batchhash()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->batchhash().data(), this->batchhash().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_datasize;
        break;
      }
      
      // required int32 datasize = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_datasize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &datasize_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_datatype;
        break;
      }
      
      // required int32 datatype = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_datatype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &datatype_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }
      
      // required string data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->data().data(), this->data().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_returnaddress;
        break;
      }
      
      // required string returnaddress = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_returnaddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_returnaddress()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->returnaddress().data(), this->returnaddress().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Data::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string batchhash = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->batchhash().data(), this->batchhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->batchhash(), output);
  }
  
  // required int32 datasize = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->datasize(), output);
  }
  
  // required int32 datatype = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->datatype(), output);
  }
  
  // required string data = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->data().data(), this->data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->data(), output);
  }
  
  // required string returnaddress = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->returnaddress().data(), this->returnaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->returnaddress(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Data::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string batchhash = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->batchhash().data(), this->batchhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->batchhash(), target);
  }
  
  // required int32 datasize = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->datasize(), target);
  }
  
  // required int32 datatype = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->datatype(), target);
  }
  
  // required string data = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->data().data(), this->data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->data(), target);
  }
  
  // required string returnaddress = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->returnaddress().data(), this->returnaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->returnaddress(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Data::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string batchhash = 1;
    if (has_batchhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->batchhash());
    }
    
    // required int32 datasize = 2;
    if (has_datasize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->datasize());
    }
    
    // required int32 datatype = 3;
    if (has_datatype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->datatype());
    }
    
    // required string data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data());
    }
    
    // required string returnaddress = 5;
    if (has_returnaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->returnaddress());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Data::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Data* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Data*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Data::MergeFrom(const Data& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_batchhash(from.batchhash());
    }
    if (from._has_bit(1)) {
      set_datasize(from.datasize());
    }
    if (from._has_bit(2)) {
      set_datatype(from.datatype());
    }
    if (from._has_bit(3)) {
      set_data(from.data());
    }
    if (from._has_bit(4)) {
      set_returnaddress(from.returnaddress());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Data::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Data::CopyFrom(const Data& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Data::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void Data::Swap(Data* other) {
  if (other != this) {
    std::swap(batchhash_, other->batchhash_);
    std::swap(datasize_, other->datasize_);
    std::swap(datatype_, other->datatype_);
    std::swap(data_, other->data_);
    std::swap(returnaddress_, other->returnaddress_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Data::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Data_descriptor_;
  metadata.reflection = Data_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Tasks_Task::_default_task_;
#ifndef _MSC_VER
const int Tasks_Task::kTasksizeFieldNumber;
const int Tasks_Task::kTaskFieldNumber;
#endif  // !_MSC_VER

Tasks_Task::Tasks_Task()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Tasks_Task::InitAsDefaultInstance() {
}

Tasks_Task::Tasks_Task(const Tasks_Task& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Tasks_Task::SharedCtor() {
  _cached_size_ = 0;
  tasksize_ = 0;
  task_ = const_cast< ::std::string*>(&_default_task_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Tasks_Task::~Tasks_Task() {
  SharedDtor();
}

void Tasks_Task::SharedDtor() {
  if (task_ != &_default_task_) {
    delete task_;
  }
  if (this != default_instance_) {
  }
}

void Tasks_Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Tasks_Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Tasks_Task_descriptor_;
}

const Tasks_Task& Tasks_Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();  return *default_instance_;
}

Tasks_Task* Tasks_Task::default_instance_ = NULL;

Tasks_Task* Tasks_Task::New() const {
  return new Tasks_Task;
}

void Tasks_Task::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tasksize_ = 0;
    if (_has_bit(1)) {
      if (task_ != &_default_task_) {
        task_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Tasks_Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 tasksize = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tasksize_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task;
        break;
      }
      
      // required string task = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->task().data(), this->task().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Tasks_Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 tasksize = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tasksize(), output);
  }
  
  // required string task = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->task().data(), this->task().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->task(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Tasks_Task::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 tasksize = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->tasksize(), target);
  }
  
  // required string task = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->task().data(), this->task().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->task(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Tasks_Task::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 tasksize = 1;
    if (has_tasksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tasksize());
    }
    
    // required string task = 2;
    if (has_task()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Tasks_Task::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Tasks_Task* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Tasks_Task*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Tasks_Task::MergeFrom(const Tasks_Task& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_tasksize(from.tasksize());
    }
    if (from._has_bit(1)) {
      set_task(from.task());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Tasks_Task::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Tasks_Task::CopyFrom(const Tasks_Task& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tasks_Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Tasks_Task::Swap(Tasks_Task* other) {
  if (other != this) {
    std::swap(tasksize_, other->tasksize_);
    std::swap(task_, other->task_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Tasks_Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Tasks_Task_descriptor_;
  metadata.reflection = Tasks_Task_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::std::string Tasks::_default_batchhash_;
#ifndef _MSC_VER
const int Tasks::kBatchhashFieldNumber;
const int Tasks::kTaskFieldNumber;
#endif  // !_MSC_VER

Tasks::Tasks()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Tasks::InitAsDefaultInstance() {
}

Tasks::Tasks(const Tasks& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Tasks::SharedCtor() {
  _cached_size_ = 0;
  batchhash_ = const_cast< ::std::string*>(&_default_batchhash_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Tasks::~Tasks() {
  SharedDtor();
}

void Tasks::SharedDtor() {
  if (batchhash_ != &_default_batchhash_) {
    delete batchhash_;
  }
  if (this != default_instance_) {
  }
}

void Tasks::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Tasks::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Tasks_descriptor_;
}

const Tasks& Tasks::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_client_2eproto();  return *default_instance_;
}

Tasks* Tasks::default_instance_ = NULL;

Tasks* Tasks::New() const {
  return new Tasks;
}

void Tasks::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (batchhash_ != &_default_batchhash_) {
        batchhash_->clear();
      }
    }
  }
  task_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Tasks::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string batchhash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_batchhash()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->batchhash().data(), this->batchhash().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task;
        break;
      }
      
      // repeated .client.Tasks.Task task = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_task:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_task()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_task;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Tasks::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string batchhash = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->batchhash().data(), this->batchhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->batchhash(), output);
  }
  
  // repeated .client.Tasks.Task task = 2;
  for (int i = 0; i < this->task_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->task(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Tasks::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string batchhash = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->batchhash().data(), this->batchhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->batchhash(), target);
  }
  
  // repeated .client.Tasks.Task task = 2;
  for (int i = 0; i < this->task_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->task(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Tasks::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string batchhash = 1;
    if (has_batchhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->batchhash());
    }
    
  }
  // repeated .client.Tasks.Task task = 2;
  total_size += 1 * this->task_size();
  for (int i = 0; i < this->task_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->task(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Tasks::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Tasks* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Tasks*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Tasks::MergeFrom(const Tasks& from) {
  GOOGLE_CHECK_NE(&from, this);
  task_.MergeFrom(from.task_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_batchhash(from.batchhash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Tasks::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Tasks::CopyFrom(const Tasks& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tasks::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < task_size(); i++) {
    if (!this->task(i).IsInitialized()) return false;
  }
  return true;
}

void Tasks::Swap(Tasks* other) {
  if (other != this) {
    std::swap(batchhash_, other->batchhash_);
    task_.Swap(&other->task_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Tasks::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Tasks_descriptor_;
  metadata.reflection = Tasks_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client

// @@protoc_insertion_point(global_scope)
